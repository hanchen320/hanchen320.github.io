 //--------------------------------------------------------------------------*
//文件名: KBI_I.c                                                           *
//说  明: KBI构件函数源文件                                                 *
//--------------------------------------------------------------------------*


//头文件包含，及宏定义区

    //头文件包含
    #include         "KBI_I.h"                  //键盘构件头文件

//构件函数实现
     
    //----------------------------------------------------------------------*
    //函数名:KBInit:键盘初始化函数                                          *
    //功  能:初始化键盘控制寄存器及相关的键盘中断寄存器,但未开放键盘中断    *
    //参  数:无                                                             *
    //返  回:无                                                             *
    //----------------------------------------------------------------------*
    void KBInit(void)
    {
    
        GPPort_Set(KB_P,PTI,1,0x0f);   //复位相应寄存器
        GPPort_Set(KB_P,DDR,0,0xF0);   //定义列线(PTP0~3)为输入
        
        //GPPort_Set(KB_A,PRT,0,0xF0);   //复位相应寄存器
        //GPPort_Set(KB_A,DDR,1,0x0F);   //行线(PTA0~3)为输出
        GPPort_Set(KB_A,PRT,0,0x0f);   //复位相应寄存器
        GPPort_Set(KB_A,DDR,1,0xf0);   //行线(PTA0~3)为输出
        
        GPPort_Set(KB_P,PER,1,0x0F);   //输入引脚(列线)有内部上拉电阻
        GPPort_Set(KB_P,PPS,0,0xF0);   //下降沿产生中断
        DisableKBint();                //禁止键盘中断      
        GPPort_Set(KB_P,PIF,1,0x0F);   //清除键盘中断请求
    }

  //--------------------------------------------------------------------------*
//文件名: KBI_I.c                                                           *
//说  明: KBI构件函数源文件                                                 *
//--------------------------------------------------------------------------*


//头文件包含，及宏定义区

    //头文件包含
    #include         "KBI_I.h"                  //键盘构件头文件

//构件函数实现
     
    //----------------------------------------------------------------------*
    //函数名:KBInit:键盘初始化函数                                          *
    //功  能:初始化键盘控制寄存器及相关的键盘中断寄存器,但未开放键盘中断    *
    //参  数:无                                                             *
    //返  回:无                                                             *
    //----------------------------------------------------------------------*
    void KBInit(void)
    {
    
        GPPort_Set(KB_P,PTI,1,0x0F);   //复位相应寄存器
        GPPort_Set(KB_P,DDR,0,0xF0);   //定义列线(PTP0~3)为输入
        
        //GPPort_Set(KB_A,PRT,0,0xF0);   //复位相应寄存器
        //GPPort_Set(KB_A,DDR,1,0x0F);   //行线(PTA0~3)为输出
        GPPort_Set(KB_A,PRT,0,0x0f);   //复位相应寄存器
        GPPort_Set(KB_A,DDR,1,0xf0);   //行线(PTA0~3)为输出
        
        GPPort_Set(KB_P,PER,1,0x0F);   //输入引脚(列线)有内部上拉电阻
        GPPort_Set(KB_P,PPS,0,0xF0);   //下降沿产生中断
        DisableKBint();                //禁止键盘中断      
        GPPort_Set(KB_P,PIF,1,0x0F);   //清除键盘中断请求
    }

    //----------------------------------------------------------------------*
    //函数名:KBScan1:扫描1次4*4键盘,返回读取的键值                          *
    //功  能:扫描1次4*4键盘,返回扫描到的键值,若无按键,返回0xff              *
    //参  数:无                                                             *
    //返  回:扫描到的键值                                                   *
    //----------------------------------------------------------------------*
    uint8 KBScan1(void)
    {
        uint8 i,tmp;
        for (i = 0; i <= 3; i++)      //最多将扫描4根行线
        {
            //GPPort_Set(KB_A,PRT,1,0x0F); //当前扫描的一行,输出低电平
            //GPPort_Set(KB_A,PRT,0,~(1<<i));
            
            GPPort_Set(KB_A,PRT,1,0xf0); //当前扫描的一行,输出低电平
            GPPort_Set(KB_A,PRT,0,~(1<<(i+4)));

            asm("NOP");
            asm("NOP");
                                      //读取键盘口数据寄存器
            tmp=GPPort_Get(KB_P,PTI)&0x0F;
            //通过观察4根列线中是否出现低电平来判断当前行有无按键 
            if (tmp != 0x0F)                  //当前行有键按下
            {
              //tmp= (tmp<<4)|(GPPort_Get(KB_A,PRT)&0x0F);
              tmp= (tmp<<4)|((GPPort_Get(KB_A,PRT)&0xf0)>>4);
              break;                          //退出循环不再扫描
             }
        }
        if (i == 4)                           //无按键,以后将返回0xff
            tmp = 0xFF;
        return (tmp);
    }

    //----------------------------------------------------------------------*
    //函数名:KBDef:键值转为定义值函数                                       *
    //功  能:键值转为定义值                                                 *
    //参  数:键值valve                                                      *
    //返  回:键定义值                                                       *
    //----------------------------------------------------------------------*
    //键盘定义表
    const uint8 KBTable[] =
    {
        0xEE,'D',0xDE,'C',0xBE,'B',0x7E,'A',
        0xED,'#',0xDD,'9',0xBD,'6',0x7D,'3',
        0xEB,'0',0xDB,'8',0xBB,'5',0x7B,'2',
        0xE7,'*',0xD7,'7',0xB7,'4',0x77,'1',
        0x00
    };
    uint8 KBDef(uint8 valve)
    {
        uint8 KeyPress;             //键定义值
        uint8 i;
        i = 0;
        KeyPress = 0xff;
        while (KBTable[i] != 0x00)  //在键盘定义表中搜索欲转换的键值,直至表尾
        {
            if(KBTable[i] == valve) //在表中找到相应的键值
            {
                KeyPress = KBTable[i+1];  //取出对应的键定义值
                break;
            }
            i += 2;                       //指向下一个键值,继续判断
        }
        return KeyPress;
    }

    //----------------------------------------------------------------------*
    //函数名:KBScanN:多次扫描键盘函数                                       *
    //功  能:多次扫描键盘，消除"抖动"                                       *
    //参  数:重复扫描键盘的的次数(KB_count)                                 *
    //返  回:多次扫描键盘得到的键值                                         *
    //说  明:本函数调用了KBscan1函数                                        *
    //----------------------------------------------------------------------*
    uint8 KBScanN(uint8 KB_count)
    {
        uint8 i,KB_value_last,KB_value_now;
        //先扫描一次得到的键值,便于下面比较 
        if (0 == KB_count || 1 == KB_count)
            return KBScan1();   
        KB_value_now = KB_value_last = KBScan1();   
        //以下多次扫描消除误差 
        for (i=0; i<KB_count-1; i++)
        {               
            KB_value_now = KBScan1();
            if (KB_value_now == KB_value_last)
                return KB_value_now;                       //返回扫描的键值
            else
                KB_value_last = KB_value_now;
                
        }
        //返回出错标志 
        return 0xFF;
    }